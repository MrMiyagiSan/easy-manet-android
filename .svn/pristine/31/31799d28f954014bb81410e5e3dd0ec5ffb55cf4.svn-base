/**
 * 
 */
package es.upv.grc.easymanet.android.services;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;

import org.simpleframework.xml.Serializer;
import org.simpleframework.xml.core.Persister;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.net.DhcpInfo;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;
import es.upv.grc.easymanet.android.MainActivity;
import es.upv.grc.easymanet.android.Node;
import es.upv.grc.easymanet.android.NodeList;
import es.upv.grc.easymanet.android.User;


/**
 * @author Salavador Morera i Soler
 *
 */
public class AnnounceAndDicoveryService { 
	// Debugging
	private static final String TAG = "AnnounceAndDiscoveryService";
	private static final boolean D = true;
	// Member fields
	private final Handler mHandler;
	private DiscoveryThread mDiscoveryThread;
	private AnnounceThread mAnnounceThread;
	private Context mContext;
	private ArrayList<User> mUsersAL;
	private NodeList mNodeList;
	protected static InetAddress myBcastIP, myLocalIP;
	// Constants
	public static final int BCAST_PORT = 12580;



	/**
	 * Constructor.
	 * @param context  El Context de la (main)Activity UI
	 * @param handler  El Handler para comunicarse con la Activity UI
	 */
	public AnnounceAndDicoveryService(Context context, Handler.Callback handler) {
		mContext = context;
		mHandler = (Handler)handler;
	}


	/**
	 * Inicia el Service.
	 * Lanza un Thread de escucha (DiscoveryThread) para recibir las listas de usuarios(nodos) y
	 * un Thread que anuncia por broadcast periódicamente la lista propia de usuarios(nodos) conocidos.
	 */
	public synchronized void start() {
		if (D) Log.d(TAG, "start");
		
		mNodeList = new NodeList();
		
		try {
			mNodeList.mNodes.add(new Node(getLocalAddress().toString(), new Date(), new Date()));
			mNodeList.mNodes.add(new Node(getLocalAddress().toString(), new Date(), new Date()));
			mNodeList.mNodes.add(new Node(getLocalAddress().toString(), new Date(), new Date()));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		mAnnounceThread = new AnnounceThread();
//		mDiscoveryThread = new DiscoveryThread();
		mAnnounceThread.start();
//		mDiscoveryThread.start();

	}


	/**
	 * Detiene el Service.
	 */
	public synchronized void stop() {
		if (D) Log.d(TAG, "stop");
		if (mDiscoveryThread != null) {mDiscoveryThread.cancel(); mDiscoveryThread = null;}
	}	


	/**
	 * Este Thread escucha para obtener las listas de nodos de otros usuarios,
	 * las compara con la lista propia actual, y si descubre nuevos nodos, obtiene
	 * los detalles de los usuarios, pasándoselos a la MainActivity.
	 */    
	private class DiscoveryThread extends Thread {

		DatagramSocket mSocket ;

		public DiscoveryThread() {

			try { 
				myBcastIP 	= getBroadcastAddress();
				if(D)Log.d(TAG,"my bcast ip : "+myBcastIP);

				myLocalIP 	= getLocalAddress();
				if(D)Log.d(TAG,"my local ip : "+myLocalIP);

				mSocket = new DatagramSocket(BCAST_PORT); 
				mSocket.setBroadcast(true); 

			} catch (IOException e) { 
				Log.e(TAG, "Could not make socket", e); 
			} 
		}

		public void run() {

			try {

				byte[] buf = new byte[1024]; 

				//Listen on socket to receive messages 
				while (true) { 
					DatagramPacket packet = new DatagramPacket(buf, buf.length); 
					mSocket.receive(packet); 

					InetAddress remoteIP = packet.getAddress();
					if(remoteIP.equals(myLocalIP))
						continue;

					String s = new String(packet.getData(), 0, packet.getLength()); 
					if(D)Log.d(TAG, "Received response " + s); 

					// Send the obtained bytes to the UI Activity
					mHandler.obtainMessage(MainActivity.NEW_USER,-1,-1, s)
					.sendToTarget();
				} 
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		/**
		 * Write broadcast packet.
		 */
		public void write(byte[] buffer) {

			try {
				String data = new String (buffer);

				DatagramPacket packet = new DatagramPacket(data.getBytes(), data.length(), 
						myBcastIP, BCAST_PORT);

				mSocket.send(packet); 
				// Share the sent message back to the UI Activity
				mHandler.obtainMessage(MainActivity.USER_REQUESTS_SERVICE, -1, -1, buffer)
				.sendToTarget();
			} catch (Exception e) {
				Log.e(TAG, "Exception during write", e);
			}
		}

		public void cancel() {
			try {
				mSocket.close();
			} catch (Exception e) {
				Log.e(TAG, "close() of connect socket failed", e);
			}
		}
	}    

	private class AnnounceThread extends Thread {
		//  TODO implementar el Thread de envío de listas
		DatagramSocket mSocket ;
		Serializer serializer = new Persister();

		public AnnounceThread() {

			try { 
//				myBcastIP 	= getBroadcastAddress();
//				if(D)Log.d(TAG,"my bcast ip : "+myBcastIP);
//
//				myLocalIP 	= getLocalAddress();
//				if(D)Log.d(TAG,"my local ip : "+myLocalIP);
				
				if(D)Log.d(TAG, "Entering AnnounceThread Constructor");
				
				mSocket = new DatagramSocket(BCAST_PORT);
				mSocket.setBroadcast(true); 
				

			} catch (IOException e) { 
				Log.e(TAG, "Could not make socket", e); 
			} 
		}


		public void run() {

			try {

				byte[] buf; 

				//Listen on socket to receive messages 
				while (true) { 
					if(D)Log.d(TAG, "AnnunceThread.run()");
					ByteArrayOutputStream out = new ByteArrayOutputStream();
					try {
						serializer.write(mNodeList, out);
					} catch (Exception e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
					if(D)Log.d(TAG, mNodeList.toString());
					buf = out.toByteArray();
					
					if(D)Log.d(TAG, out.toString());
					DatagramPacket packet = new DatagramPacket(buf, buf.length, getBroadcastAddress(), BCAST_PORT); 
					mSocket.send(packet);
//					mSocket.receive(packet); 
//
//					InetAddress remoteIP = packet.getAddress();
//					if(remoteIP.equals(myLocalIP))
//						continue;
//
//					String s = new String(packet.getData(), 0, packet.getLength()); 
//					if(D)Log.d(TAG, "Received response " + s); 
//
//					// Send the obtained bytes to the UI Activity
//					mHandler.obtainMessage(MainActivity.USER_REQUESTS_SERVICE,-1,-1, s)
//					.sendToTarget();
					try
					{
						AnnounceThread.sleep(500);
					} catch (InterruptedException e){
						
					}
				} 
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	/** 
	 * Calculate the broadcast IP we need to send the packet along. 
	 */ 
	private InetAddress getBroadcastAddress() throws IOException {
		WifiManager mWifi = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);

		WifiInfo info = mWifi.getConnectionInfo();
		if(D)Log.d(TAG,"\n\nWiFi Status: " + info.toString());

		// DhcpInfo  is a simple object for retrieving the results of a DHCP request
		DhcpInfo dhcp = mWifi.getDhcpInfo(); 
		if (dhcp == null) { 
			Log.d(TAG, "Could not get dhcp info"); 
			return null; 
		} 

		int broadcast = (dhcp.ipAddress & dhcp.netmask) | ~dhcp.netmask; 
		byte[] quads = new byte[4]; 
		for (int k = 0; k < 4; k++) 
			quads[k] = (byte) ((broadcast >> k * 8) & 0xFF);

		return InetAddress.getByAddress(quads); // The high order byte is quads[0].
	}  


	private InetAddress getLocalAddress()throws IOException {

		try {
			for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
				NetworkInterface intf = en.nextElement();

				for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
					InetAddress inetAddress = enumIpAddr.nextElement();

					if (!inetAddress.isLoopbackAddress()) {
						//return inetAddress.getHostAddress().toString();
						return inetAddress;
					}
				}
			}
		} catch (SocketException ex) {
			Log.e(TAG, ex.toString());
		}
		return null;
	}


	/**
	 * @return the mNodeList
	 */
	public NodeList getmNodeList() {
		return mNodeList;
	}


	/**
	 * @param mNodeList the mNodeList to set
	 */
	public void setmNodeList(NodeList mNodeList) {
		this.mNodeList = mNodeList;
	}
}
